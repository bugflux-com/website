---
title: C#
description: Bugflux reporting library for C#.
category: Reporting libraries
layout: guide
order: 5.02
---

* [Getting started](#Getting-started)
 * [Installation](#Instalation)
 * [First use](#First-use)
* [Your configuration](#Your-configuration)
 * [Config class](#Config-class)
 * [ProjectClientInfo class](#ProjectClientInfo-class)
 * [Report class](#Report-class)
 * [Configuration example](#Configuration-example)
* [Uncaught exceptions handling](#Uncaught-exceptions-handling)
 * [Default Bugflux handler](#Default-Bugflux-handler)
 * [Your handler](#Your-handler)
 * [Many default configurations](#Many-default-configurations)
* [Send result](#Send-result)
 * [Mistakes examples](#Mistakes-examples)
 * [Common exceptions during report sending](#Common-exceptions-during-report-sending)
* [Include Trace in message field](#Include-Trace-in-message-field)
* [Tips](#Tips)


## Getting started

### Installation

You can download the code from our github page. All you need to do is adding created `Bugflux.dll` or whole Bugflux project as reference to your project.

You can also download our C# library using NuGet. To install Bugflux, run the following command in the Package Manager Console: `Install-Package Bugflux`

### First use

The easiest way of using Bugflux library is shown below:

```csharp
using System;
using Bugflux;

namespace BugfluxExample
{
    class Example1 
    {
        static void Main(string[] args)
        {
            Config myConfig = new Config("https://bugflux.your-domain.com");
            myConfig.ProjectAndClientInfo.ProjectKey = "abcd1234";

            try
            {
                throw new Exception("Something bad happened!");
            }
            catch (Exception ex)
            {
                Report report = new Report(ex);
                report.Send(myConfig);
            }
        }
    }
}
```
This example shows how to set your bugflux server address - you need to create `Config` object by passing server address in its constructor. Then you should set `ProjectKey` to key generated by server. After catching an exception you should create new `Report` using this exception and then send it using your config.

After running code shown above on your bugflux server you should see that new error has been reported.

Tip: If report didn't show up on your server, check [Send result](#Send-result) section at first and after resolving your problem go back here.

## Your configuration

As you probably see above example doesn't specify project environment and version, information about client who is running the application and other fields which are required, as written in our [API documentation](/api/v1/errors.html). This is because they are using default values (see following detailed description for more information). However you may need to set your own values to identify error more accuratly - in that case Bugflux C# library provides interface to directly manipulate all fields related with API.

### Config class

This class is keeping all configuration needed for correct error reporting. The table below shows some fields of `Config`. The rest is described later in this guide, in more detail.

Field | Description | Default value
--- | ---
ServerAddress | Address of your Bugflux server. | https://bugflux
ApiVersion | Api version, used in address where to send reports. We recommend not to change it. | "v1"
ErrosPath | Path after api version in address where errors should be sent. We recommend not to change it. | "/errors"
StrictSSL | Whether to use SSL strictly in https connections. If not, the server's certificate isn't checked. We recommend not to change it, only for development and testing purposes. | true 
IncludeTraceInMessage | Whether to include information from Trace class in Message field. Read more [here](#Include-Trace-in-Message-field) | false

### ProjectClientInfo class

Some of report information can be held in `ProjectClientInfo` object. Fields of this class are listed in table:

Field | Corresponding field in api | Default value
--- | --- | ---
ProjectKey | project | "00000000"
Version | version | Taken from entry assembly info. If it is not possible it is 0.0.0.0
Language | language | "en_US"
Environment | environment | "Development" if debugger is attached, "Production" otherwise.
ClientId | client_id | Hash of string combined from baseboard and bios serial numbers, processor id and uuid of the system. If none of these values is available it is set to Report.FAIL_HASH.
OperatingSystem | system | If it is possible, it is taken from Win32_OperatingSystem otherwise set to "Unknown". For Unix and Mac it is "UNIX OR MAC".

In order to access fields described above you can use `ProjectAndClientInfo` property (of type `ProjectClientInfo`) of `Config` object.

### Report class

Report holds information connected with one particular exception. 

Field | Corresponding field in api | Default value
--- | --- | ---
Name | name | Message property of Exception to report. If empty or null, class of the exception.
Hash | hash | Computed from exception type and file name and method where exception occurred. If it is not possible to get this data it is set to Report.FAIL_HASH.
Message | message | Empty 
StackTrace | stack_trace | StackTrace property of Exception to report. If null (because Exception wasn't thrown), it is stack trace of place, where report was created.

Mentioned `Report.FAIL_HASH` is static string of `Report` class used during computation of `ProjectClientInfo.ClientId` and `Report.Hash` fields as a fallback for all other methods. It's default value is "BugfluxDefaultFailHash", but of course you can change it.

### Configuration example

By accessing members of `ProjectClientInfo` and `Report` classes you can create and send error report which fully addresses your requirements.

Following example presents how this could be achieved (please note that, for example, version number does not follow Bugflux recommendation). 
```csharp
using System;
using Bugflux;

namespace BugfluxExample
{
    class Example2
    {
        static void Main(string[] args)
        {
            Config myConfig = new Config("https://bugflux.your-domain.com");

            myConfig.ProjectAndClientInfo = new ProjectClientInfo("abcd1234", "v1.2");
            myConfig.ProjectAndClientInfo.Language = "pl_PL";

            try {
                throw new Exception("Something bad happened again!");
            }
            catch (Exception ex)
            {
                Report report = new Report(ex, "I am dissapointed!", "MyExceptionInExample2");
                report.Hash = "MyHash";
                report.Send(myConfig);
            }
        }
    }
}
```
As you can see some properties are passed to constructors and other are set by accessing them directly. Actually all properties excluding `ProjectClientInfo.OperatingSystem`, `ProjectClientInfo.ClientId` and `Report.StackTrace` can be passed to constructors and all can be set by direct access. 

In our example "abcd1234" is project key, "v1.2" is its version, "pl_PL" is language, "I am dissapointed!" is message, "MyExceptionInExample2" is error name and "MyHash" is error hash. 

After running the code you should see on your server that second error was reported.

## Uncaught exceptions handling

In both presented examples you cought an exception and then sent it to your bugflux server. We know that it is rare when a programmer remember to write try catch statements in all places in code where it is needed. To meet this natural human distraction .NET allows you to create something called default uncought exceptions handler. Possibly you are using it in your C# applications, as it is quite simple to do so (you can read about it in Microsoft documentation [here](https://msdn.microsoft.com/en-us/library/system.appdomain.unhandledexception.aspx)). 

### Default Bugflux handler

Bugflux provides its handler for uncought exceptions. To turn it on all you need to do is setting static field `Config.EnableDefaultBehaviour` to true.

But, what about configuration, you will ask. That's right - how can our default handler knows where to send the data, and what should be project name, version and so on? This configuration can be set using static `Config.DefaultConfig`. Example below shows you how to do it:

```csharp
using System;
using Bugflux;

namespace BugfluxExample
{
    class Example3
    {
        static void Main(string[] args)
        {
            Config.EnableDefaultBehaviour = true;
            Config.DefaultConfig.ServerAddress = "https://bugflux.your-domain.com";
            Config.DefaultConfig.ProjectAndClientInfo.ProjectKey = "abcd1234";
            Config.DefaultConfig.ProjectAndClientInfo.ClientId = "MyBestClient";

            throw new Exception("Something bad happened third time!"); 
        }
    }
}
```
In the example strings with our informations are assigned to `Config.DefaultConfig` object's fields. You can also create new config and set it as default one. Note that after running this code the proccess will be terminated. So having uncought exceptions handler doesn't mean that your program is error-resistant, it only lets you do action just before proccess closing.

After running code above you should see in the console output from bugflux default handler:
`Default bugflux exception handler: Something bad happened third time!`
If you want to disable printing error information by our default handler you should set `Config.Silent` to true (default is false).

Remember that printed information doesn't mean that sending succeed - you are not able to check the result. If you want to do it, see the next subsection with your handler.

You can also use `Config.DefaultConfig` as parameter to `send` method of your report.

### Your handler

As it was said, uncought exception makes system terminate your program. Usually in this situation you want to save work or show user that there was an error and that program will exit. Bugflux provides an option for you to do it (you don't need to read mentioned Microsoft documentation).

Custom handler can be used for example to ask user to provide additional information in what circustances the error has occured. Example below shows a simple approach which could be taken to do so:

```csharp
using System;
using Bugflux;

namespace BugfluxExample
{
    class Example4
    {
        static void Main(string[] args)
        {
            Config myConfig = new Config("https://bugflux.your-domain.com");

            myConfig.ProjectAndClientInfo.ProjectKey = "abcd1234";
            myConfig.ProjectAndClientInfo.Version = "3.0.2";
            myConfig.ProjectAndClientInfo.Environment = "Production";

            Config.setUnhandledExceptionHandler((sender, args) => {
                Console.WriteLine("Unhandled exception occurred. Please tell us what happened:");
                string message = Console.ReadLine();

                var report = new Report((Exception)args.ExceptionObject);
                report.Message = message;
                report.Send(myConfig);
                Console.WriteLine("Thank you! Your message has been sent with error report.");
            });

            throw new Exception("Something bad happened fourth time!");
        }
    }
}
```

In this example arguments `sender` and `args` are of types `object` and `UnhandledExceptionEventArgs` respectively.
In place of lambda expression you could also pass normal function.

Bugflux itself supports at one time only one your handler (if multiple calls to `Config.SetUnhandledExceptionHandler` are made, only the last one is valid). However C# mechanism allows multiple listeners, which can be add by you manually. In such case Bugflux does not change them.

Warning! Please note that Buglux's default handler (enabled by `Config.EnableDefaultBahaviour`) is not considered as normal error handler and therefore is not mutually exclusive with one provided by you (both can be active at the same time). Remember to not turn on Bugflux's handler if you are using yours to send the data to server to avoid double reports. 

When you run this code, write in console message imitating user's description of the exception, for example:
`I just pressed enter and program crashed :(`
 

### Many default configurations

It may sounds strange but Bugflux gives you opportunity to use many default configs. It was designed for people who want to have two or more servers, each of them is supposed to receive all the errors reported, and send reports using default bugflux uncought exceptions handler. If you are not planning to have more than one server just skip this point.

Imagine that on your first server you project's key is "abcd1234" and on second server it's "xyz12345". The code is here:

```csharp
using System;
using Bugflux;

namespace BugfluxExample
{
    class Example5
    {
        static void Main(string[] args)
        {
            Config.EnableDefaultBehaviour = true;
            
            Config.DefaultConfig.ServerAddress = "https://bugflux.your-domain.com";
            Config.DefaultConfig.ProjectAndClientInfo.ProjectKey = "abcd1234";

            Config nextConfig = new Config("https://bugflux2.your-domain.com");
            nextConfig.ProjectAndClientInfo.ProjectKey = "xyz12345";
            Config.AddDefaultConfig(nextConfig);

            throw new Exception("Something bad happened fifth time!");
        }
    }
}
```

As you see, second config can be added using static `Config.AddDefaultConfig` method. You can add this way more configs, as many as you wish.

You can remove last added configuration using static `Config.RemoveLastDefaultConfig` function. If you didn't add any configuration, or all added configurations were removed, it has no effect.

It is also possible to get the list of all default configurations, including `Config.DefaultConfig` using static field `Config.DefaultConfigs`.

After running the code, if you didn't add to it line setting `Silent` property to true, you should see two messages in the output:
`Default bugflux exception handler: Something bad happened fifth time!`
`Sent using 2 configurations.`
The second information is shown if there is more than one configuration.

Again - remember that printed information doesn't mean that sending succeed (sent here actually means that bugflux library tried to send information twice, but we can't be sure that servers received the reports).

## Send result

You know how to set all api fields, configure you connection with server and also how to handle uncought exceptions. Now let's learn what to do with the result of `send` function.

The object returned by this method is of `Result` class. It can be casted implicitly to bool which says whether sending succeed. `Result` has four fields:

Field | Description
--- | ---
ExceptionThrown | Exception which was thrown when trying to send data to server.
JsonTriedToBeSent | Json string which was tried to be send to server.
ServerResponseIfOK | HttpWebResponse received from server if it accepted to process the report.
ServerResponseBodyIfOK | String with body of the response from server if it accepted to process the report.

The second field is always set, no matter if sending failed or not. `ExceptionThrown` is set always, when server didn't response with 2xx code (code was different or we didn't receive the answer) and is the only information which you can get about the result.

Third and fourth fields are set in case of accepting to process the data by server. Actually you shouldn't need them - usually if server approved your report, you doesn't need the response (in this api version the body is empty). In case of fail, both properties are set to nulls.

### Mistakes examples

Let's imagine the situation that you forget to create new `Config` and assigned null to you config variable.  

```csharp
using System;
using Bugflux;

namespace BugfluxExample
{
    class Example6
    {
        static void Main(string[] args)
        {
            Config myConfig = null;

            try
            {
                throw new Exception("Something bad happened sixth time!");
            }
            catch (Exception ex)
            {
                Report report = new Report(ex);
                var result = report.Send(myConfig);
                if (!result) {
                    Console.WriteLine("Exception of type: " + result.ExceptionThrown.GetType());
                    Console.WriteLine("Message: " + result.ExceptionThrown.Message);
                }
                else
                    Console.WriteLine("Sent correctly.")
            }
        }
    }
}
```

In the output you should see:
`Exception of type: System.NullReferenceException`
`Message: Object reference not set to an instance of an object.`

If you wrote also the `JsonTriedToBeSent` property, you would see that it is set to "{}". Because `myConfig` was null, it was impossible to create correct json string.

Let's go to the next example. Here hash of the exception contains characters which are not allowed.

```csharp
using System;
using Bugflux;

namespace BugfluxExample
{
    class Example7
    {
        static void Main(string[] args)
        {
            Config myConfig = new Config("https://bugflux.your-domain.com");
            myConfig.ProjectAndClientInfo.ProjectKey = "abcd1234";

            try
            {
                throw new Exception("Something bad happened seventh time!");
            }
            catch (Exception ex)
            {
                Report report = new Report(ex);
                report.Hash = "Hash with not permitted characters ? ! $";
                var result = report.Send(myConfig);
                if (!result)
                {
                    Console.WriteLine("Exception of type: " + result.ExceptionThrown.GetType());
                    Console.WriteLine("Message: " + result.ExceptionThrown.Message);
                    var body = result.GetServerResponseBody();
                    if (body != null)
                        Console.WriteLine("Response: " + body);
                }
                else
                    Console.WriteLine("Sent correctly.")
            }
        }
    }
}
```

You can see that we used `GetServerResponseBody` method of `Result` object. This method gets the body from `ExceptionThrown` only if it is possible (for instance exception must be of type `System.Net.WebException`), otherwise returns null. There is also similarly behaving method `GetServerResponse`, which gets `System.Net.WebResponse` from exception. You can use it to read its headers or response uri.

The result in your console should look like this:
`Exception of type: System.Net.WebException`
`Message: The remote server returned an error: (422) Unprocessable Entity.`
`Response: {"message":"The given data failed to pass validation.","errors":{"hash":["The hash may only contain letters and numbers."]}}`

The body in the response is in fact in format described [here](/api/v1/errors.html#Response) in our documentation. When you see 422 error, you can get `JsonTriedToBeSent` property and see what is wrong with it.

### Common exceptions during report sending

In the table below you can see list of common exceptions thrown during attempts to send a report.

result.ExceptionThrown.Message | Possible reason
--- | ---
Object reference not set to an instance of an object. | Described above.
The remote server returned an error: (422) Unprocessable Entity. | Described above.
The remote name could not be resolved: 'your_address' | You provided incorrect server address (`ServerAddress`) or no internet connection.
The remote server returned an error: (404) Not Found. | You provided incorrect address to error reporting (also `ServerAddress` or maybe you changed `ApiVersion` or `ErrosPath`).
The underlying connection was closed: Could not establish trust relationship for the SSL/TLS secure channel. | You server does not have valid certificate or it cannot be confirmed. If you are just testing, set `StrictSSL` to false.


## Include Trace in message field

If you are using `Trace` class to trace execution of your program, this section is for you. Bugflux C# library supports sending information gathered by `Trace` class in message field of the request. All what you should do is setting `IncludeTraceInMessage` property of your config to true. Below there is an example on how to do it with default Bugflux handler.

```csharp
using System;
using Bugflux;

namespace BugfluxExample
{
    class Example8
    {
        static void Main(string[] args)
        {
            Config.EnableDefaultBehaviour = true;
            Config.DefaultConfig.ServerAddress = "https://bugflux.your-domain.com";
            Config.DefaultConfig.ProjectAndClientInfo.ProjectKey = "abcd1234";
            Config.DefaultConfig.IncludeTraceInMessage = true;
            
            Trace.WriteLine("My Trace information");
            Trace.WriteLine("..another information...");
            Trace.WriteLine("And next Trace information...");

            throw new Exception("Something bad happened eighth time!"); 
        }
    }
}
```
You can see on server, that report generated by this code has message containing information written using `Trace` class. If you set `IncludeTraceInMessage` to true and then to false, all informations written before setting to false will be lost. You can invoke `GetTraceInformation` method of `Config` object to get current gathered information. You can also call `ClearInformationFromTrace` method to clear all information. This can be useful if you write really much data using `Trace`.

Information from `Trace` is not assigned to `Message` field of `Report` class, it is only written to json. If you turned on including `Trace` informations in message, but want your (different from Trace) message for one particular report, you should just pass message in constructor or set `Message` property. Of course you should do it before creating json. Information from `Trace` won't be included as message - this happens only if `Message` property is empty.

## Tips

* Remember that it is better to throw exceptions. Exception which was not thrown doesn't have `StackTrace` property. Report will be sent with stack_trace set to place where report was created - sometimes it is ok, but sometimes, if you created Exception earlier, it is not.


* `StackOverflowException` is the only exception which cannot be cought. It is also impossible to handle it using uncought exceptions handling (either provided by Bugflux or your own). All that user gets is the message: `Process is terminated due to StackOverflowException`. See [link](https://blogs.msdn.microsoft.com/jaredpar/2008/10/22/when-can-you-catch-a-stackoverflowexception/) for more information.


* Language used in exceptions depends on `CultureInfo` for the thread, which is taken from user Region and Language settings in Control Panel. If you want to have all exceptions names in one language, you can change it using `Thread.CurrentThread.CurrentCulture`, but remember that it will also change whole culture - calender used, formating dates and numbers etc. 


* Our library shorten all api fields to their max length. For example if you try to assign string with length greater than 255 to `Project` property of `Config` object, additional chars will be omitted. It also doesn't allow you to assign nulls and empty strings to all required fields. However other constrains as alfanumerical one on hash field aren't checked.


* You can use `createJSON` method of `Report` object to just create json without sending it.


* You can use static method `sendJSON` of `Report` class to send json created by you (or by `createJSON` method).