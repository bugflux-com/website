---
title: Java
description: Bugflux reporting library for Java.
category: Reporting libraries
layout: guide
order: 5.03
---

* [Getting started](#Getting-started)
 * [Installation](#Instalation)
 * [First use](#First-use)
* [Your configuration](#Your-configuration)
 * [Config class](#Config-class)
 * [ProjectClientInfo class](#ProjectClientInfo-class)
 * [Report class](#Report-class)
 * [Configuration example](#Configuration-example)
* [Uncaught exceptions handling](#Uncaught-exceptions-handling)
 * [Default Bugflux handler](#Default-Bugflux-handler)
 * [Your handler](#Your-handler)
 * [Many default configurations](#Many-default-configurations)
* [Send result](#Send-result)
 * [Mistakes examples](#Mistakes-examples)
 * [Common exceptions during report sending](#Common-exceptions-during-report-sending)
* [Tips](#Tips)


## Getting started

Our Java library is based on our C# library. The main differences arise from Java practises (as setters) and possibilities (for example it is hard to get motherboard serial number what is possible in C#). If you used our C# lib you will immediately know how to use Java lib and vice versa. However, you should at least whip through the guide refering to other language library.

### Installation

You can download `Bugflux.jar` from our github page. Bugflux Java library needs following depedencies: `json-simple-1.1.1.jar`, `httpcore-4.4.4.jar`, `commons-logging-1.2.jar` and `httpclient-4.5.2.jar`. All you need to do is adding it and its depedencies as reference to your project. You can also download our library in combined form `Bugflux-combined.jar` which already contains all depedencies within itself.

You can also download our Java library using maven.

### First use

The easiest way of using Bugflux library is shown below:

```java
package bugfluxExample;

import Bugflux.*;


public class BugfluxExample1 
{
    public static void main(String[] args)
    {
        Config myConfig = new Config("https://bugflux.your-domain.com");
        myConfig.getProjectAndClientInfo().setProjectKey("abcd1234");

        try
        {
            throw new Exception("Something bad happened!");
        }
        catch (Exception ex)
        {
            Report report = new Report(ex);
            report.send(myConfig);
        }
        
    }
}
```
This example shows how to set your bugflux server address - you need to create `Config` object by passing server address in its constructor. Then you should set `projectKey` to key generated by server. After catching an exception you should create new `Report` using this exception and then send it using your config.

After running code shown above on your bugflux server you should see that new error has been reported.

Tip: If report didn't show up on your server, check [Send result](#Send-result) section at first and after resolving your problem go back here.

## Your configuration

As you probably see above example doesn't specify project environment and version, information about client who is running the application and other fields which are required, as written in our [API documentation](/api/v1/errors.html). This is because they are using default values (see following detailed description for more information). However you may need to set your own values to identify error more accuratly - in that case Bugflux Java library provides interface to directly manipulate all fields related with API.

### Config class

This class is keeping all configuration needed for correct error reporting. The table below shows some public fields of `Config`. The rest is described later in this guide, in more detail.

Field | Description | Default value
--- | ---
serverAddress | Address of your Bugflux server. | https://bugflux
apiVersion | Api version, used in address where to send reports. We recommend not to change it. | "v1"
errosPath | Path after api version in address where errors should be sent. We recommend not to change it. | "/errors"
strictSSL | Whether to use SSL strictly in https connections. If not, the server's certificate isn't checked. We recommend not to change it, only for development and testing purposes. | true 

### ProjectClientInfo class

Some of report information can be held in `ProjectClientInfo` object. Fields of this class are listed in table:

Field | Corresponding field in api | Default value
--- | --- | ---
projectKey | project | "00000000"
version | version | "1.0.0"
language | language | "en_US"
environment | environment | "Development" if debugger is attached, "Production" otherwise.
clientId | client_id | Hash of string with serial number of bios. If it is not available it is set to Report.FAIL_HASH.
OperatingSystem | system | If it is possible, it is taken from Win32_OperatingSystem otherwise set to "Unknown".

In order to access fields described above you can use `projectAndClientInfo` field (of type `ProjectClientInfo`) of `Config` object.

### Report class

Report holds information connected with one particular exception. 

Field | Corresponding field in api | Default value
--- | --- | ---
name | name | Message field of exception to report. If empty or null, class of the exception.
hash | hash | Computed from exception type and file name and method where exception occurred. If it is not possible to get this data it is set to Report.FAIL_HASH.
message | message | Empty 
stackTrace | stack_trace | StackTrace field of exception to report.

Mentioned `Report.FAIL_HASH` is static string of `Report` class used during computation of `ProjectClientInfo.ClientId` and `Report.Hash` fields as a fallback for all other methods. It's default value is "BugfluxDefaultFailHash", but of course you can change it.

### Configuration example

By accessing members of `ProjectClientInfo` and `Report` classes you can create and send error report which fully addresses your requirements.

Following example presents how this could be achieved (please note that, for example, version number does not follow Bugflux recommendation). 
```java
package bugfluxExample;

import Bugflux.*;


public class BugfluxExample2 
{
    public static void main(String[] args)
    {
        Config myConfig = new Config("https://bugflux.your-domain.com");

        ProjectClientInfo pci = new ProjectClientInfo("abcd1234", "v1.2");
        pci.setLanguage("pl_PL");
        myConfig.setProjectAndClientInfo(pci);

        try {
            throw new Exception("Something bad happened again!");
        }
        catch (Exception ex)
        {
            Report report = new Report(ex, "I am dissapointed!", "MyExceptionInExample2");
            report.setHash("MyHash");
            report.send(myConfig);
        }
    }
}
```
As you can see some fields' values are passed to constructors and other are set by their setters. Actually all fields excluding `ProjectClientInfo.operatingSystem`, `ProjectClientInfo.clientId` and `Report.stackTrace` can be passed to constructors and all can be set by setters. 

In our example "abcd1234" is project key, "v1.2" is its version, "pl_PL" is language, "I am dissapointed!" is message, "MyExceptionInExample2" is error name and "MyHash" is error hash. 

After running the code you should see on your server that second error was reported.

## Uncaught exceptions handling

In both presented examples you cought an exception and then sent it to your bugflux server. We know that it is rare when a programmer remember to write try catch statements in all places in code where it is needed. To meet this natural human distraction Java allows you to create something called default uncought exceptions handler. Possibly you are using it in your Java applications, as it is quite simple to do so (you can read about it in Java documentation [here](https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.UncaughtExceptionHandler.html)). 

### Default Bugflux handler

Bugflux provides its handler for uncought exceptions using mentioned mechanism. To turn it on all you need to do is setting static field `Config.enableDefaultBehaviour` to true.

But, what about configuration, you will ask. That's right - how can our default handler knows where to send the data, and what should be project name, version and so on? This configuration can be set using static `Config.defaultConfig`. Example below shows you how to do it:

```java
package bugfluxExample;

import Bugflux.*;


public class BugfluxExample3 
{
    public static void main(String[] args)
    {
        Config.setEnableDefaultBehaviour(true);
        Config defaultConfig = Config.getDefaultConfig();
        defaultConfig.serverAddress = "https://bugflux.your-domain.com";
        ProjectClientInfo pci = defaultConfig.getProjectAndClientInfo();
        pci.setProjectKey("abcd1234");
        pci.setClientId("MyBestClient");

        throw new Exception("Something bad happened third time!"); 
    }
}
```
In the example strings with our informations are assigned to `Config.defaultConfig` object's fields. You can also create new config and set it as default one. Note that after running this code the proccess will be terminated. So having uncought exceptions handler doesn't mean that your program is error-resistant, it only lets you do action just before proccess closing.

After running code above you should see in the console output from bugflux default handler:
`Default bugflux exception handler: Something bad happened third time!`
If you want to disable printing error information by our default handler you should set `Config.silent` to true (default is false).

Remember that printed information doesn't mean that sending succeed - you are not able to check the result. If you want to do it, see the next subsection with your handler.

You can also use `Config.defaultConfig` as parameter to `send` method of your report.

You can see on the server that next error was reported.

### Your handler

As it was said, uncought exception makes system terminate your program. Usually in this situation you want to save work or show user that there was an error and that program will exit.

Unlike C#, Java supports only one handler for uncought exceptions. Therefore our lib doesn't let you add your own handler. If you want to create it, find on the internet how to do it - there is plenty of examples. Remember that adding you own handler will disable bugflux handler and other way around. 

### Many default configurations

It may sounds strange but Bugflux gives you opportunity to use many default configs. It was designed for people who want to have two or more servers, each of them is supposed to receive all the errors reported, and send reports using default bugflux uncought exceptions handler. If you are not planning to have more than one server just skip this point.

Imagine that on your first server you project's key is "abcd1234" and on second server it's "xyz12345". The code is here:

```java
package bugfluxExample;

import Bugflux.*;


public class BugfluxExample4 
{
    public static void main(String[] args)
    {
        Config.setEnableDefaultBehaviour(true);
        
        Config defaultConfig = Config.getDefaultConfig();
        defaultConfig.serverAddress = "https://bugflux.your-domain.com";
        defaultConfig.getProjectAndClientInfo().setProjectKey("abcd1234");

        Config nextConfig = new Config("https://bugflux2.your-domain.com");
        nextConfig.getProjectAndClientInfo().setProjectKey("xyz12345");
        Config.AddDefaultConfig(nextConfig);

        throw new Exception("Something bad happened fourth time!");
    }
}
```

As you see, second config can be added using static `Config.addDefaultConfig` method. You can add this way more configs, as many as you wish.

You can remove last added configuration using static `Config.removeLastDefaultConfig` function. If you didn't add any configuration, or all added configurations were removed, it has no effect.

It is also possible to get the list of all default configurations, including `Config.defaultConfig` using static method `Config.getDefaultConfigs()`.

After running the code, if you didn't add to it line setting `silent` property to true, you should see two messages in the output:
`Default bugflux exception handler: Something bad happened fourth time!`
`Sent using 2 configurations.`
The second information is shown if there is more than one configuration.

Again - remember that printed information doesn't mean that sending succeed (sent here actually means that bugflux library tried to send information twice, but we can't be sure that servers received the reports).

## Send result

You know how to set all api fields, configure you connection with server and also how to handle uncought exceptions. Now let's learn what to do with the result of `send` function.

The object returned by this method is of `Result` class. You can use `Result.isOK()` method to tell whether sending succeed or not. `Result` has three fields:

Field | Description
--- | ---
exceptionThrown | Throwable which was thrown when trying to send data to server.
jsonTriedToBeSent | Json string which was tried to be send to server.
response | HttpResponse returned by server.

The second field is always set, no matter if sending failed or not. `exceptionThrown` is set always, when server didn't response with 2xx code (code was different or we didn't receive the answer). `response` is set when server responsed (whatever the answer and code were).

### Mistakes examples

Let's imagine the situation that you forget to create new `Config` and assigned null to you config variable.  

```java
package bugfluxExample;

import Bugflux.*;


public class BugfluxExample5 
{
    public static void main(String[] args)
    {
        Config myConfig = null;

        try
        {
            throw new Exception("Something bad happened fifth time!");
        }
        catch (Exception ex)
        {
            Report report = new Report(ex);
            Result result = report.send(myConfig);
            if (!result.isOK())
                System.out.println("Exception of type: " + result.exceptionThrown.getClass().toString());
            else
                System.out.println("Sent correctly.");
        }
    }
}
```

In the output you should see:
`Exception of type: class java.lang.NullPointerException`

If you wrote also the `jsonTriedToBeSent` field, you would see that it is set to "{}". Because `myConfig` was null, it was impossible to create correct json string.

Let's go to the next example. Here hash of the exception contains characters which are not allowed.

```java
package bugfluxExample;

import Bugflux.*;


public class BugfluxExample6 
{
    public static void main(String[] args)
    {
        Config myConfig = new Config("https://bugflux.your-domain.com");
        myConfig.getProjectAndClientInfo().setProjectKey("abcd1234");

        try
        {
            throw new Exception("Something bad happened sixth time!");
        }
        catch (Exception ex)
        {
            Report report = new Report(ex);
            report.setHash("Hash with not permitted characters ? ! $");
            Result result = report.send(myConfig);
            if (!result.isOK())
            {
                System.out.println("Exception of type: " + result.exceptionThrown.getClass().toString());
                System.out.println("Message: " + result.exceptionThrown.getMessage());
                String body = result.getServerResponseBody();
                if (body != null)
                    System.out.println("Response: " + body);
            }
            else
                System.out.println("Sent correctly.");
        }
    }
}
```

You can see that we used `getServerResponseBody` method of `Result` object. This method gets the body of response only if it is possible, otherwise returns null.

The result in your console should look like this:
`Exception of type: class Bugflux.Report$WrongBugfluxServerAnswerException`
`Message: Check response to know the reason.`
`Response: {"message":"The given data failed to pass validation.","errors":{"hash":["The hash may only contain letters and numbers."]}}`

The body in the response is in fact in format described [here](/api/v1/errors.html#Response) in our documentation.

When you see WrongBugfluxServerAnswerException error meaning that server answer is wrong this may stand for a lot of reasons. Firstly Server might have rejected your report, you can get the body as in above example and if message is telling that `The given data failed to pass validation`, you know what is wrong. But wrong server answer could also mean that you provided incorrect server address, version or errors path. We reccomend to check the status code using `result.response.getStatusLine().getStatusCode();`.

### Common exceptions during report sending

In the table below you can see list of common exceptions thrown during attempts to send a report.

result.exceptionThrown.getClass().toString() | Possible reason
--- | ---
class java.lang.NullPointerException | Described above.
class Bugflux.Report$WrongBugfluxServerAnswerException | Described above.
class org.apache.http.client.ClientProtocolException | You provided incorrect address to error reporting (probably with http not https protocol).
class java.net.UnknownHostException | No internet connetion or wrong server address.
class javax.net.ssl.SSLHandshakeException (or other connected with SSL) | You server does not have valid certificate or it cannot be confirmed. If you are just testing, set `StrictSSL` to false.


## Tips

* Remember to set version of the application - for example in C# library it is taken from assembly info, what is not possible in Java.


* In Java you shouldn't worry about stack overflow exception - default exception handler can handle it!


* Our library shorten all api fields to their max length. For example if you try to assign string with length greater than 255 to `Project` property of `Config` object, additional chars will be omitted. It also doesn't allow you to assign nulls to all required fields. However other constrains as alfanumerical one on hash field aren't checked.


* You can use `createJSON` method of `Report` object to just create json without sending it.


* You can use static method `sendJSON` of `Report` class to send json created by you (or by `createJSON` method). 


* For now, Java lib sets defaultly ClientId only for Windows. On other systems you should provide it.


* Operating system can be sometimes set as Windows 8 for Windows 10. To avoid it, application should use Java 8 Update 60 at least. 